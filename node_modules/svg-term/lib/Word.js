"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const styled_1 = __importDefault(require("@emotion/styled"));
const color_1 = require("./color");
exports.Word = props => {
    return (React.createElement(React.Fragment, null,
        (props.inverse || props.bg) && (React.createElement(StyledWordBackground, { bg: props.bg, fg: props.fg, height: props.theme.fontSize * props.theme.lineHeight, inverse: props.inverse, width: props.children.length > 0 ? props.children.length : 0, x: props.x * props.theme.fontSize * 0.6, y: props.y - props.theme.fontSize })),
        React.createElement(StyledWord, { bg: props.bg, bold: props.bold, fg: props.fg, inverse: props.inverse, theme: props.theme, underline: props.underline, x: props.x * props.theme.fontSize * 0.6, y: props.y }, props.children)));
};
const BG_FILL = (props) => props.inverse ? fg(props, props.theme) : bg(props, props.theme);
const TEXT_FILL = (props) => props.inverse ? bg(props, props.theme) : fg(props, props.theme);
const DECORATION = (props) => (props.underline ? "underline" : null);
const FONT_WEIGHT = (props) => (props.bold ? "bold" : null);
const StyledWordBackground = styled_1.default.rect `
  fill: ${BG_FILL};
`;
const StyledWord = styled_1.default.text `
  fill: ${TEXT_FILL};
  text-decoration: ${DECORATION};
  font-weight: ${FONT_WEIGHT};
  white-space: pre;
`;
function bg(props, theme) {
    const b = typeof props.bg === "undefined" ? theme.background : props.bg;
    return color_1.color(b, theme, theme.background);
}
function fg(props, theme) {
    const d = props.bold ? theme.bold : theme.text;
    // Bold takes precedence if fg is undefined or 0
    if (props.bold && !props.fg) {
        return color_1.color(theme.bold, theme);
    }
    const f = typeof props.fg === "undefined" ? d : props.fg;
    return color_1.color(f, theme, d);
}
//# sourceMappingURL=Word.js.map